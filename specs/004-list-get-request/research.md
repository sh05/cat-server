# 技術研究: ファイル一覧取得エンドポイント

**研究期間**: 2025-09-20
**対象機能**: `/list` エンドポイント実装

## 研究項目と決定事項

### 1. 既存HTTPサーバー構造の理解

**調査結果**:
- **ルーティング**: `http.NewServeMux()` を使用、Go 1.22+ の新しいパターンマッチング (`GET /health`)
- **ハンドラー構造**: `handlers` パッケージで分離、関数ベースのハンドラー
- **エラーハンドリング**: 構造化ログ (`log/slog`) + 標準的な HTTP エラーレスポンス
- **レスポンス形式**: Accept ヘッダーベースの複数形式サポート (JSON/HTML/Text)
- **サーバー設定**: タイムアウト設定済み (Read: 10s, Write: 10s, Idle: 60s)

**決定**: `/list` エンドポイントも同様のパターンで実装
- `handlers.ListHandler` 関数を作成
- JSON レスポンス優先、エラーハンドリング統一
- 構造化ログによるリクエスト追跡

**根拠**: 既存コードとの一貫性、保守性確保

### 2. ディレクトリ読み込み最適化

**技術比較**:

| 手法 | パフォーマンス | メモリ効率 | 隠しファイル対応 | 適用判定 |
|------|---------------|------------|------------------|----------|
| `os.ReadDir()` | 高速 | 効率的 | 簡単 | ✅ 採用 |
| `filepath.WalkDir()` | 中程度 | 中程度 | 複雑 | ❌ 過剰 |
| `os.File.Readdir()` | 低速 | 非効率 | 中程度 | ❌ 非推奨 |

**決定**: `os.ReadDir()` + 手動フィルタリング
```go
entries, err := os.ReadDir(dirPath)
for _, entry := range entries {
    if !entry.IsDir() {  // ファイルのみ
        files = append(files, entry.Name())  // 隠しファイル含む
    }
}
```

**根拠**:
- Go 1.16+ 推奨API、最高のパフォーマンス
- メモリフットプリント最小
- 隠しファイル（ドット開始）は自然に含まれる
- 大量ファイル時もメモリ安全

**検討した代替案**:
- `filepath.WalkDir()`: 再帰処理が不要のため過剰
- `ioutil.ReadDir()`: Go 1.16で非推奨、パフォーマンス劣る

### 3. コマンドライン引数解析

**現在の実装**: 引数解析なし、ハードコードされたポート `:8080`

**決定**: `flag` パッケージによる標準的な引数解析
```go
var dirFlag = flag.String("dir", "./files/", "Directory to list files from")
flag.Parse()
```

**根拠**:
- Go 標準ライブラリ、外部依存なし
- 仕様要件 (デフォルト `./files/`, `-dir` フラグ) に完全対応
- 既存のシンプルな設計思想に合致

**検討した代替案**:
- 環境変数: 実行時柔軟性が劣る
- 第三者CLI ライブラリ: 憲法違反（外部依存最小化）

### 4. JSON レスポンス形式設計

**要件**: "keyはなんでもよく、valueでファイル名一覧を表現"

**決定**: 柔軟でわかりやすい構造
```json
{
  "files": ["file1.txt", ".hidden", "file2.go"],
  "directory": "/path/to/dir",
  "count": 3
}
```

**根拠**:
- `files` キー: 意味が明確、既存 API パターンに合致
- `directory`: デバッグ時の確認用
- `count`: クライアント利便性向上
- 既存 health エンドポイントの JSON 形式と一貫性

**検討した代替案**:
- `{"data": [...]}`: 汎用的だが意味が不明確
- `{"list": [...]}`: エンドポイント名と重複

### 5. エラーハンドリング戦略

**既存パターン**: health ハンドラーの統一的エラー処理

**決定**: 同様のエラーレスポンス形式
```json
{
  "error": "directory not found",
  "path": "/invalid/path",
  "timestamp": "2025-09-20T10:00:00Z"
}
```

**エラーケース別対応**:
- ディレクトリ不存在: 400 Bad Request
- 権限エラー: 403 Forbidden
- システムエラー: 500 Internal Server Error

**根拠**: 既存の health エンドポイントとの一貫性、RESTful 設計原則

## 技術スタック確定

### 使用ライブラリ (Go 標準のみ)
- `net/http`: HTTP サーバー、ルーティング
- `encoding/json`: JSON エンコード/デコード
- `os`: ディレクトリ読み込み
- `flag`: コマンドライン引数解析
- `log/slog`: 構造化ログ
- `path/filepath`: パス操作 (検証用)

### パフォーマンス目標
- **レスポンス時間**: <100ms (1000ファイル以下)
- **メモリ使用量**: 10MB 以下 (10000ファイル時)
- **同時リクエスト**: 100req/s まで対応

### セキュリティ考慮事項
- パストラバーサル攻撃防止: 指定ディレクトリ外アクセス禁止
- 入力検証: 無効パス、null バイト チェック
- リソース制限: 大量ファイル時のタイムアウト設定

## 実装アーキテクチャ

### レイヤー分離
1. **Handler層** (`handlers/list.go`): HTTP リクエスト処理
2. **Service層** (`services/directory.go`): ビジネスロジック
3. **Main層** (`main.go`): 引数解析、サーバー設定

### テスト戦略
- **ユニットテスト**: Service 層の独立テスト
- **統合テスト**: Handler の HTTP リクエスト/レスポンス
- **契約テスト**: OpenAPI 仕様準拠確認

## 最終確認

✅ **すべての要明確化を解決**:
- 既存アーキテクチャとの統合パターン確定
- ディレクトリ読み込み最適化手法選択
- JSON レスポンス形式設計完了
- エラーハンドリング戦略統一

✅ **憲法原則準拠**:
- Go 標準ライブラリのみ使用
- 外部依存関係なし
- シンプルで理解しやすい設計
- 既存コードとの一貫性維持

---
**次フェーズ**: フェーズ1（設計とコントラクト）実行準備完了
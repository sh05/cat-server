# 実装計画: ファイル一覧取得エンドポイント (/list)

**ブランチ**: `004-list-get-request` | **日付**: 2025-09-20 | **仕様書**: [spec.md](./spec.md)
**入力**: `/specs/004-list-get-request/spec.md` からの機能仕様
**ユーザー指示**: 現状の仕様を確認して実装して、READMEなどの更新も忘れないで

## 実行フロー (/plan コマンド範囲)
```
1. 入力パスから機能仕様をロード
   → 完了: spec.md から /list エンドポイント仕様を読み込み
2. 技術コンテキストを記入 (要明確化をスキャン)
   → プロジェクトタイプ: single (CLI アプリケーション + HTTP サーバー)
   → Go標準ライブラリベースの実装
3. 憲法文書の内容に基づいて憲法チェックセクションを記入
   → 完了: Go言語、テスト要件、品質ゲートを確認
4. 以下の憲法チェックセクションを評価
   → 違反なし: cat-server の機能拡張として適切
   → 進捗追跡を更新: 初期憲法チェック合格
5. フェーズ0を実行 → research.md
   → HTTP サーバー実装パターン、ディレクトリ読み込み最適化を研究
6. フェーズ1を実行 → contracts, data-model.md, quickstart.md, CLAUDE.md更新
   → REST API仕様、JSON レスポンス構造、統合テストを設計
7. 憲法チェックセクションを再評価
   → 設計レビュー実行
8. フェーズ2を計画 → タスク生成アプローチを説明
9. 停止 - /tasks コマンドの準備完了
```

**重要**: /planコマンドはステップ8で停止します。フェーズ2-4は他のコマンドで実行されます:
- フェーズ2: /tasks コマンドが tasks.md を作成
- フェーズ3-4: 実装実行 (手動またはツール経由)

## 概要
API利用者がHTTP GETリクエストで特定ディレクトリのファイル一覧（隠しファイル含む）を取得できる `/list` エンドポイントを実装。コマンドライン引数 `-dir` でディレクトリ指定可能（デフォルト: `./files/`）。Go標準ライブラリを使用し、既存のHTTPサーバー構造に追加する形で実装。

## 技術コンテキスト
**言語/バージョン**: Go (最新安定版)
**主要依存関係**: Go標準ライブラリ (net/http, os, path/filepath, encoding/json)
**ストレージ**: ローカルファイルシステム
**テスト**: Go組み込みテストフレームワーク (go test)
**対象プラットフォーム**: Unix/Linux/macOS/Windows (Go標準対応)
**プロジェクトタイプ**: single (CLI + HTTPサーバー統合)
**パフォーマンス目標**: 1000ファイル以下のディレクトリで応答時間 <100ms
**制約**: メモリ使用量最小化、大量ファイル時の安全な処理
**規模/範囲**: 既存cat-serverへの機能追加、新規エンドポイント1つ

## 憲法チェック
*GATE: フェーズ0研究前に合格必須。フェーズ1設計後に再チェック。*

**言語ポリシー**:
- [x] 内部ドキュメント (仕様書、計画、タスク) は日本語で記述
- [x] 外部ドキュメント (README, APIドキュメント) は英語で記述
- [x] コードコメントとコミットは英語で記述

**Go標準**:
- [x] Go プログラミング言語のみを使用
- [x] Go コミュニティのベストプラクティスとイディオムに従う
- [x] 外部依存関係を最小化 (Go標準ライブラリのみ使用)

**テスト要件**:
- [x] すべての関数/メソッドに対するユニットテストを計画
- [x] Go の組み込みテストフレームワークを使用
- [x] TDD アプローチ: 実装前にテスト

**品質ゲート**:
- [x] go vet, go fmt, go test, go build 検証を計画に含める
- [x] 品質ゲートのCI/CD強制を計画

**簡素性**:
- [x] 機能が cat-server のコア目的と一致 (ファイル操作ユーティリティ)
- [x] 不要な複雑性と抽象化を避ける (標準ライブラリベース)

## プロジェクト構造

### ドキュメント (この機能)
```
specs/004-list-get-request/
├── plan.md              # このファイル (/plan コマンド出力)
├── research.md          # フェーズ0出力 (/plan コマンド)
├── data-model.md        # フェーズ1出力 (/plan コマンド)
├── quickstart.md        # フェーズ1出力 (/plan コマンド)
├── contracts/           # フェーズ1出力 (/plan コマンド)
└── tasks.md             # フェーズ2出力 (/tasks コマンド - /plan では作成されない)
```

### ソースコード (リポジトリルート)
```
src/
├── server/              # 既存HTTPサーバー (健康チェック用)
├── handlers/            # HTTPリクエストハンドラー (既存: health, 新規: list)
├── services/            # ビジネスロジック (新規: directory listing)
└── main.go             # アプリケーション エントリポイント (引数解析拡張)

tests/
├── contract/           # OpenAPI仕様準拠テスト
├── integration/        # エンドツーエンド テスト
├── unit/              # ユニットテスト
└── performance/       # 負荷テスト

bin/                   # コンパイル済みバイナリ
```

**構造決定**: 既存のcat-server単一プロジェクト構造を拡張、新規ディレクトリ最小限

## フェーズ0: 概要と研究

### 研究項目:
1. **既存HTTPサーバー構造の理解**:
   - 現在の health エンドポイント実装パターン
   - ルーティング、ミドルウェア、エラーハンドリング方式
   - 既存の引数解析とサーバー起動フロー

2. **ディレクトリ読み込み最適化**:
   - filepath.WalkDir vs os.ReadDir パフォーマンス比較
   - 大量ファイル時のメモリ効率的な処理方法
   - 隠しファイル（ドット開始）フィルタリング手法

3. **Go HTTP ベストプラクティス**:
   - JSON レスポンス標準化
   - エラーレスポンス形式統一
   - Content-Type ヘッダー管理

**研究エージェント**:
```
タスク: "Go HTTPサーバーにおけるディレクトリ一覧取得の最適化パターンを研究"
タスク: "cat-serverの既存アーキテクチャとの統合パターンを調査"
タスク: "ファイルシステム操作における Go ベストプラクティスを見つける"
```

**出力**: research.md (決定事項、技術選択根拠、代替案評価)

## フェーズ1: 設計とコントラクト
*前提条件: research.md 完了*

### 設計ドキュメント生成:

1. **data-model.md**:
   - DirectoryPath エンティティ (入力検証ルール)
   - FileList エンティティ (ファイル名コレクション)
   - APIResponse エンティティ (JSON構造定義)

2. **contracts/list-endpoint.yaml**:
   - GET /list OpenAPI 3.0 仕様
   - レスポンススキーマ (成功: 200, エラー: 400/500)
   - パラメータ仕様 (サーバー起動時の -dir フラグ)

3. **contracts/ のテストファイル**:
   - 契約テスト (OpenAPI仕様準拠確認)
   - スキーマ検証テスト (JSON構造チェック)

4. **quickstart.md**:
   - 機能デモ手順 (サーバー起動 → curlテスト → 結果確認)
   - 統合テストシナリオ (spec.md の受け入れ条件)

5. **CLAUDE.md 更新**:
   - /list エンドポイント開発コマンド追加
   - テスト実行手順更新

**出力**: 全設計ドキュメント、失敗する契約テスト、実行可能クイックスタート

## フェーズ2: タスク計画アプローチ
*このセクションは /tasks コマンドが行うことを説明 - /plan では実行しない*

**タスク生成戦略**:
- TDD順序: コントラクトテスト → ユニットテスト → 実装
- 既存構造活用: handlers/ 拡張、main.go 引数解析拡張
- 独立性: directory service を分離してテスト容易性確保

**タスク種別**:
- [P] コントラクトテスト作成 (並列実行可能)
- DirectoryService ユニットテスト作成
- ListHandler ユニットテスト作成
- [P] DirectoryService 実装 (並列実行可能)
- ListHandler 実装
- main.go 引数解析拡張
- 統合テスト実装
- パフォーマンステスト作成
- README.md 更新

**順序戦略**:
1. テスト → 実装
2. Service → Handler → Main
3. ユニット → 統合 → パフォーマンス

**推定出力**: tasks.md 内の12-15の番号付き順序タスク

**重要**: このフェーズは /tasks コマンドで実行され、/plan では実行されません

## フェーズ3以降: 今後の実装
*これらのフェーズは /plan コマンドの範囲外です*

**フェーズ3**: タスク実行 (/tasks コマンドが tasks.md を作成)
**フェーズ4**: 実装 (憲法原則に従って tasks.md を実行)
**フェーズ5**: 検証 (品質ゲート、quickstart.md 実行、パフォーマンス確認)

## 複雑性追跡
*憲法チェックに正当化が必要な違反がある場合のみ記入*

違反なし - すべて憲法原則に準拠

## 進捗追跡
*このチェックリストは実行フロー中に更新される*

**フェーズステータス**:
- [x] フェーズ0: 研究完了 (/plan コマンド) - research.md 生成済み
- [x] フェーズ1: 設計完了 (/plan コマンド) - data-model.md, contracts/, quickstart.md, CLAUDE.md更新済み
- [x] フェーズ2: タスク計画完了 (/plan コマンド - アプローチ説明のみ)
- [ ] フェーズ3: タスク生成 (/tasks コマンド)
- [ ] フェーズ4: 実装完了
- [ ] フェーズ5: 検証合格

**ゲートステータス**:
- [x] 初期憲法チェック: 合格
- [x] 設計後憲法チェック: 合格 - すべて憲法原則準拠
- [x] すべての要明確化を解決 - research.md で全項目解決済み
- [x] 複雑性逸脱を文書化 (該当なし)

---
*憲法 v1.0.0 ベース - `.specify/memory/constitution.md` を参照*
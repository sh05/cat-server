# 技術調査結果: REST API Webサーバー

**調査日**: 2025-09-20
**目的**: Go言語標準ライブラリを使用したHTTPサーバー実装のベストプラクティス調査

## 1. Go net/httpパッケージのベストプラクティス

**決定**: Go標準`net/http`パッケージとGo 1.22の拡張ルーティング機能を基盤とする

**根拠**:
- Go 1.22で導入されたルーティング改善により、サードパーティルーティングライブラリが不要
- 標準ライブラリは組み込み並行性サポートにより高負荷トラフィックを効率的に処理
- 新しいルーティング構文でHTTP動詞とパスパラメータをサポート: `mux.HandleFunc("GET /task/{id}/", handler)`
- 下位互換性を維持しながらモダンなルーティング機能を提供
- `http.Handler`インターフェースを実装する広範なGoエコシステムとシームレスに統合

**検討した代替案**:
- **サードパーティフレームワーク (chi, gorilla/mux, gin)**: 追加機能提供だが、Go 1.22のルーティング機能で大半のシンプル〜中程度複雑度サービスには不要
- **カスタムルーティング実装**: 標準ライブラリの拡張機能に対する顕著な利益なくして複雑さを追加

## 2. ヘルスチェックエンドポイント実装パターン

**決定**: 最小実装 - 基本的なサーバー稼働確認のみ実装、HTTP 200ステータス返却

**根拠**:
- 機能仕様でシンプルなヘルスチェック（基本的なサーバー可用性のみ）が要求されている
- 外部依存関係なしの設計により、複雑な依存性チェックは不要
- 監視システムが求める基本的な「サーバーが応答可能」状態の確認に適合
- 将来的な拡張（データベース、外部API接続チェック）のための基盤を提供

**検討した代替案**:
- **包括的な依存関係チェック**: 現在の要件を超過し、不要な複雑性を追加
- **Liveness/Readinessエンドポイント分離**: Kubernetes環境では有用だが、現在の仕様範囲外
- **非同期バックグラウンドチェック**: 過度に複雑、将来的な拡張で考慮

## 3. Go APIサーバーの推奨プロジェクト構造

**決定**: シンプルなレイアウトから開始、プロジェクト複雑性に応じて進化

```
src/
├── server/     # HTTPサーバー実装
├── handlers/   # ハンドラー関数
└── main.go     # エントリーポイント

tests/
├── integration/  # 統合テスト
└── unit/        # ユニットテスト
```

**根拠**:
- 過度なエンジニアリングを防止、構造は実際のプロジェクトニーズに応じて成長すべき
- 技術レイヤー（"models", "controllers"）ではなく機能別コードグループ化により保守性向上
- シンプルなプロジェクトに対する過度な構造化を回避

**検討した代替案**:
- **golang-standards/project-layoutの厳格な準拠**: シンプルなプロジェクトで過度なエンジニアリングを導く可能性
- **単一main.goアプローチ**: 非常にシンプルなサービスには機能するが、スケールしない
- **フレームワーク強制構造**: Goイディオムと整合せず、ベンダーロックインを作成する可能性

## 4. Go HTTPサーバーのGraceful Shutdownパターン

**決定**: `signal.NotifyContext()`をシグナル処理に使用、サーバーをgoroutineで実行、タイムアウトコンテキストで`server.Shutdown(ctx)`実装

**根拠**:
- `signal.NotifyContext()`はOSシグナルとGoのコンテキストシステム間のクリーンな統合を提供
- goroutineでのサーバー実行により、main関数でshutdownロジック処理が可能
- `server.Shutdown()`はリスナーを優雅に閉じ、アイドル接続を待機、アクティブリクエストの完了を許可
- タイムアウトコンテキストはshutdownの無限ハングを防止（30秒猶予期間のコンテナ環境で重要）
- SIGTERM (docker stop)とSIGINT (Ctrl+C)両方を適切に処理

**検討した代替案**:
- **直接シグナルチャネル処理**: `signal.NotifyContext()`より冗長でエラーが発生しやすい
- **即座のshutdown**: アクティブ接続を突然終了、ユーザー体験の悪化
- **タイムアウト処理なし**: 本番環境でhangingしてシャットダウン原因の可能性

## 5. エラーハンドリングとログ記録のベストプラクティス

**決定**: 標準ライブラリの`log/slog`パッケージを構造化ログに使用、適切なログレベル、コンテキスト付きエラーラッピング

**根拠**:
- `log/slog` (Go 1.21導入) は本番準備済み構造化ログを標準ライブラリに提供
- キー値ペアの構造化ログにより、より良い解析、フィルタリング、分析が可能
- エラーラッピングはデバッグのためエラーチェーンを維持しつつコンテキストを保持
- 標準ライブラリアプローチはモダンなログ機能を提供しつつ外部依存関係を回避
- 組み込みJSON出力サポートはログ集約システムとの良好な統合

**検討した代替案**:
- **サードパーティログライブラリ (Zap, Zerolog, Logrus)**: パフォーマンスが良いが依存関係追加、`log/slog`は大半の使用例で十分な機能を提供
- **プレーンテキストログ**: プログラム的な解析・分析が困難
- **カスタムログソリューション**: 標準ライブラリソリューション存在時の不要な複雑性

## 実装への影響

これらの技術選択により：

1. **最小依存関係**: Go標準ライブラリのみ使用
2. **将来の拡張性**: 基本実装から段階的拡張可能
3. **運用適合性**: 本番環境でのデプロイと監視に適した設計
4. **保守性**: シンプルで理解しやすい構造

## 次のステップ

フェーズ1でこれらの技術選択を具体的な設計ドキュメント（data-model.md, contracts/）とクイックスタートガイドに変換する。